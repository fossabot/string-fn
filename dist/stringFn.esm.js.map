{"version":3,"file":"stringFn.esm.js","sources":["../src/between.js","../node_modules/rambda/dist/rambda.esm.js","../src/internals/constants.js","../src/words.js","../src/wordsX.js","../src/camelCase.js","../src/count.js","../src/constantCase.js","../src/distance.js","../src/distanceGerman.js","../src/dotCase.js","../src/glob.js","../src/indent.js","../src/isLetter.js","../src/isPunctuation.js","../src/kebabCase.js","../src/trim.js","../src/internals/maskWordHelper.js","../src/maskSentence.js","../src/maskWords.js","../src/ms.js","../src/pascalCase.js","../src/removeIndent.js","../src/reverse.js","../src/seoTitle.js","../src/shuffle.js","../src/snakeCase.js","../src/splitPerLine.js","../src/splitSentence.js","../src/stripPunctuation.js","../node_modules/rambdax/dist/rambdax.esm.js","../src/getMaxLength.js","../src/fitWithinLines.js","../src/stripTags.js","../src/takeArguments.js","../src/titleCase.js"],"sourcesContent":["export function between(str, left, rightRaw){\n  // if(str === 2) return\n  const right = rightRaw === undefined ? left : rightRaw\n\n  const rightIndex = str.lastIndexOf(right)\n  const leftIndex = str.indexOf(left)\n\n  return rightIndex === -1 ?\n    str :\n    str.substring(leftIndex + left.length, rightIndex).trim()\n}\n","function add(x,y){if(y===void 0){return c=>add(x,c);}return x+y;}function addIndex(d){return function(e,...rest){let g=0;const newFn=(...args)=>e.apply(null,[...args,g++]);return d.apply(null,[newFn,...rest]);};}function adjust(h,j,k){if(j===void 0){return(l,m)=>adjust(h,l,m);}else if(k===void 0){return n=>adjust(h,j,n);}const q=k.concat();return q.map((r,s)=>{if(s===j){return h(k[j]);}return r;});}function filterObject(t,u){const v={};for(const w in u){if(t(u[w],w)){v[w]=u[w];}}return v;}function filter(z,A){if(arguments.length===1){return B=>filter(z,B);}if(A===void 0){return[];}if(!Array.isArray(A)){return filterObject(z,A);}let C=-1,D=0;const E=A.length,G=[];while(++C<E){const H=A[C];if(z(H)){G[D++]=H;}}return G;}function all(I,J){if(arguments.length===1){return K=>all(I,K);}return filter(I,J).length===J.length;}function any(L,M){if(arguments.length===1){return N=>any(L,N);}let O=0;while(O<M.length){if(L(M[O],O)){return!0;}O++;}return!1;}function allPass(P,x){if(arguments.length===1){return Q=>allPass(P,Q);}return!any(R=>!R(x),P);}function always(x){return()=>x;}function anyPass(S,x){if(arguments.length===1){return U=>anyPass(S,U);}return any(V=>V(x))(S);}function append(x,W){if(arguments.length===1){return X=>append(x,X);}if(typeof W==='string')return`${W}${x}`;const Y=W.concat();Y.push(x);return Y;}function curry(f,a=[]){return(...p)=>(o=>o.length>=f.length?f(...o):curry(f,o))([...a,...p]);}function assocRaw(Z,a1,b1){return Object.assign({},b1,{[Z]:a1});}const c1=curry(assocRaw);function both(x,y){if(arguments.length===1){return d1=>both(x,d1);}return e1=>x(e1)&&y(e1);}function complement(fn){return g1=>!fn(g1);}function compose(...fns){return(...args)=>{const h1=fns.slice();if(h1.length>0){const fn=h1.pop();let j1=fn(...args);while(h1.length>0){j1=h1.pop()(j1);}return j1;}return void 0;};}function concat(x,y){if(arguments.length===1){return k1=>concat(x,k1);}return typeof x==='string'?`${x}${y}`:[...x,...y];}function type(a){const l1=typeof a;if(a===null){return'Null';}else if(a===void 0){return'Undefined';}else if(l1==='boolean'){return'Boolean';}else if(l1==='number'){return'Number';}else if(l1==='string'){return'String';}else if(Array.isArray(a)){return'Array';}else if(a instanceof RegExp){return'RegExp';}const m1=a.toString();if(m1.startsWith('async')){return'Async';}else if(m1==='[object Promise]'){return'Promise';}else if(m1.includes('function')||m1.includes('=>')){return'Function';}return'Object';}function equals(a,b){if(arguments.length===1){return n1=>equals(a,n1);}if(a===b){return!0;}const o1=type(a);if(o1!==type(b)){return!1;}if(o1==='Array'){const p1=Array.from(a),q1=Array.from(b);if(p1.toString()!==q1.toString()){return!1;}let r1=!0;p1.forEach((s1,t1)=>{if(r1){if(s1!==q1[t1]&&!equals(s1,q1[t1])){r1=!1;}}});return r1;}if(o1==='Object'){const u1=Object.keys(a);if(u1.length!==Object.keys(b).length){return!1;}let v1=!0;u1.forEach(w1=>{if(v1){const x1=a[w1],y1=b[w1];if(x1!==y1&&!equals(x1,y1)){v1=!1;}}});return v1;}return!1;}function contains(x,z1){if(arguments.length===1){return A1=>contains(x,A1);}let B1=-1,C1=!1;while(++B1<z1.length&&!C1){if(equals(z1[B1],x)){C1=!0;}}return C1;}const dec=x=>x-1;function defaultTo(D1,E1){if(arguments.length===1){return F1=>defaultTo(D1,F1);}return E1===void 0||E1===null||Number.isNaN(E1)===!0?D1:E1;}function dissoc(G1,H1){if(arguments.length===1){return I1=>dissoc(G1,I1);}if(H1===null||H1===void 0){return{};}const J1={};for(const p in H1){J1[p]=H1[p];}delete J1[G1];return J1;}function divide(x,y){if(arguments.length===1){return K1=>divide(x,K1);}return x/y;}function drop(L1,x){if(arguments.length===1){return M1=>drop(L1,M1);}return x.slice(L1);}function dropLast(N1,x){if(arguments.length===1){return O1=>dropLast(N1,O1);}return x.slice(0,-N1);}function either(x,y){if(arguments.length===1){return P1=>either(x,P1);}return Q1=>x(Q1)||y(Q1);}function endsWith(R1,S1){if(arguments.length===1){return T1=>endsWith(R1,T1);}return S1.endsWith(R1);}function F(){return!1;}function find(fn,V1){if(arguments.length===1){return W1=>find(fn,W1);}return V1.find(fn);}function findIndex(fn,Y1){if(arguments.length===1){return Z1=>findIndex(fn,Z1);}const a2=Y1.length;let b2=-1;while(++b2<a2){if(fn(Y1[b2])){return b2;}}return-1;}function flatten(c2,d2){d2=d2===void 0?[]:d2;for(let i=0;i<c2.length;i++){if(Array.isArray(c2[i])){flatten(c2[i],d2);}else{d2.push(c2[i]);}}return d2;}function flipExport(fn){return(...input)=>{if(input.length===1){return f2=>fn(f2,input[0]);}else if(input.length===2){return fn(input[1],input[0]);}return void 0;};}function flip(fn,...input){return flipExport(fn);}function mapObject(fn,i2){const j2={};for(const k2 in i2){j2[k2]=fn(i2[k2],k2);}return j2;}function map(fn,m2){if(arguments.length===1){return n2=>map(fn,n2);}if(m2===void 0){return[];}if(!Array.isArray(m2)){return mapObject(fn,m2);}let o2=-1;const p2=m2.length,q2=Array(p2);while(++o2<p2){q2[o2]=fn(m2[o2]);}return q2;}function forEach(fn,s2){if(arguments.length===1){return t2=>forEach(fn,t2);}map(fn,s2);return s2;}function groupBy(fn,v2){if(arguments.length===1){return w2=>groupBy(fn,w2);}const x2={};for(let i=0;i<v2.length;i++){const y2=v2[i],z2=fn(y2);if(!x2[z2]){x2[z2]=[];}x2[z2].push(y2);}return x2;}function has(A2,B2){if(arguments.length===1){return C2=>has(A2,C2);}return B2[A2]!==void 0;}function head(a){if(typeof a==='string'){return a[0]||'';}return a[0];}function identity(x){return x;}function ifElse(D2,E2,F2){if(E2===void 0){return(G2,H2)=>ifElse(D2,G2,H2);}else if(F2===void 0){return I2=>ifElse(D2,E2,I2);}return J2=>{const K2=typeof D2==='boolean'?D2:D2(J2);if(K2===!0){return E2(J2);}return F2(J2);};}const inc=x=>x+1;function includes(x,y){if(arguments.length===1){return L2=>includes(x,L2);}return y.includes(x);}function indexBy(fn,N2){if(arguments.length===1){return O2=>indexBy(fn,O2);}const P2={};for(let i=0;i<N2.length;i++){const Q2=N2[i];P2[fn(Q2)]=Q2;}return P2;}function indexOf(x,R2){if(arguments.length===1){return S2=>indexOf(x,S2);}let T2=-1;const U2=R2.length;while(++T2<U2){if(R2[T2]===x){return T2;}}return-1;}function baseSlice(V2,W2,X2){let Y2=-1,Z2=V2.length;X2=X2>Z2?Z2:X2;if(X2<0){X2+=Z2;}Z2=W2>X2?0:X2-W2>>>0;W2>>>=0;const a3=Array(Z2);while(++Y2<Z2){a3[Y2]=V2[Y2+W2];}return a3;}function init(a){if(typeof a==='string'){return a.slice(0,-1);}return a.length?baseSlice(a,0,-1):[];}function is(b3,x){if(arguments.length===1){return c3=>is(b3,c3);}return x!=null&&x.constructor===b3||x instanceof b3;}function isNil(x){return x===void 0||x===null;}function join(d3,e3){if(arguments.length===1){return f3=>join(d3,f3);}return e3.join(d3);}function keys(x){return Object.keys(x);}function last(a){if(typeof a==='string'){return a[a.length-1]||'';}return a[a.length-1];}function lastIndexOf(x,g3){if(arguments.length===1){return h3=>lastIndexOf(x,h3);}let i3=-1;g3.map((j3,k3)=>{if(equals(j3,x)){i3=k3;}});return i3;}function length(x){return x.length;}function match(l3,x){if(arguments.length===1){return m3=>match(l3,m3);}const n3=x.match(l3);return n3===null?[]:n3;}function merge(o3,p3){if(arguments.length===1){return q3=>merge(o3,q3);}return Object.assign({},o3||{},p3||{});}function max(x,y){if(arguments.length===1){return r3=>max(x,r3);}return y>x?y:x;}function maxBy(fn,x,y){if(arguments.length===2){return t3=>maxBy(fn,x,t3);}else if(arguments.length===1){return(u3,v3)=>maxBy(fn,u3,v3);}return fn(y)>fn(x)?y:x;}function min(x,y){if(arguments.length===1){return w3=>min(x,w3);}return y<x?y:x;}function minByRaw(fn,x,y){return fn(y)<fn(x)?y:x;}const y3=curry(minByRaw);function modulo(x,y){if(arguments.length===1)return z3=>modulo(x,z3);return x%y;}function multiply(x,y){if(arguments.length===1)return A3=>multiply(x,A3);return x*y;}function none(fn,C3){if(arguments.length===1)return D3=>none(fn,D3);return C3.filter(fn).length===0;}function not(x){return!x;}function nth(E3,F3){if(arguments.length===1)return G3=>nth(E3,G3);const H3=E3<0?F3.length+E3:E3;return Object.prototype.toString.call(F3)==='[object String]'?F3.charAt(H3):F3[H3];}function omit(I3,J3){if(arguments.length===1){return K3=>omit(I3,K3);}if(J3===null||J3===void 0){return void 0;}const L3=typeof I3==='string'?I3=I3.split(','):I3,M3={};for(const N3 in J3){if(!L3.includes(N3)){M3[N3]=J3[N3];}}return M3;}function partialCurry(fn,P3={}){return Q3=>{if(type(fn)==='Async'||type(fn)==='Promise'){return new Promise((R3,S3)=>{fn(merge(Q3,P3)).then(R3).catch(S3);});}return fn(merge(Q3,P3));};}function path(T3,U3){if(arguments.length===1){return V3=>path(T3,V3);}if(U3===null||U3===void 0){return void 0;}let W3=U3,X3=0;const Y3=typeof T3==='string'?T3.split('.'):T3;while(X3<Y3.length){if(W3===null||W3===void 0){return void 0;}W3=W3[Y3[X3]];X3++;}return W3;}function pathOrRaw(Z3,a4,b4){return defaultTo(Z3,path(a4,b4));}const c4=curry(pathOrRaw);function pick(d4,e4){if(arguments.length===1){return f4=>pick(d4,f4);}if(e4===null||e4===void 0){return void 0;}const g4=typeof d4==='string'?d4.split(','):d4,h4={};let i4=0;while(i4<g4.length){if(g4[i4]in e4){h4[g4[i4]]=e4[g4[i4]];}i4++;}return h4;}function pickAll(j4,k4){if(arguments.length===1){return l4=>pickAll(j4,l4);}if(k4===null||k4===void 0){return void 0;}const m4=typeof j4==='string'?j4.split(','):j4,n4={};let o4=0;while(o4<m4.length){if(m4[o4]in k4){n4[m4[o4]]=k4[m4[o4]];}else{n4[m4[o4]]=void 0;}o4++;}return n4;}function pipe(...fns){return compose(...fns.reverse());}function pluck(p4,q4){if(arguments.length===1)return r4=>pluck(p4,r4);const s4=[];map(t4=>{if(!(t4[p4]===void 0)){s4.push(t4[p4]);}},q4);return s4;}function prepend(x,u4){if(arguments.length===1)return v4=>prepend(x,v4);if(typeof u4==='string'){return`${x}${u4}`;}const w4=u4.concat();w4.unshift(x);return w4;}function prop(x4,y4){if(arguments.length===1)return z4=>prop(x4,z4);return y4[x4];}function propEq(A4,x,B4){if(x===void 0){return(C4,D4)=>propEq(A4,C4,D4);}else if(B4===void 0){return E4=>propEq(A4,x,E4);}return B4[A4]===x;}function range(F4,G4){if(arguments.length===1)return H4=>range(F4,H4);const I4=[];for(let i=F4;i<G4;i++){I4.push(i);}return I4;}function reduce(fn,K4,L4){if(K4===void 0){return(M4,N4)=>reduce(fn,M4,N4);}else if(L4===void 0){return O4=>reduce(fn,K4,O4);}return L4.reduce(fn,K4);}function reject(fn,Q4){if(arguments.length===1)return R4=>reject(fn,R4);return filter(x=>!fn(x),Q4);}function repeat(x,S4){if(arguments.length===1){return T4=>repeat(x,T4);}const U4=Array(S4);return U4.fill(x);}function replace(V4,W4,X4){if(W4===void 0){return(Y4,Z4)=>replace(V4,Y4,Z4);}else if(X4===void 0){return a5=>replace(V4,W4,a5);}return X4.replace(V4,W4);}function reverse(b5){const c5=b5.concat();return c5.reverse();}function sort(fn,e5){if(arguments.length===1)return f5=>sort(fn,f5);const g5=e5.concat();return g5.sort(fn);}function sortBy(fn,i5){if(arguments.length===1){return j5=>sortBy(fn,j5);}const k5=i5.concat();return k5.sort((a,b)=>{const l5=fn(a),m5=fn(b);return l5<m5?-1:l5>m5?1:0;});}function split(n5,o5){if(arguments.length===1)return p5=>split(n5,p5);return o5.split(n5);}function splitEvery(q5,x){if(arguments.length===1)return r5=>splitEvery(q5,r5);const s5=q5>1?q5:1,t5=[];let u5=0;while(u5<x.length){t5.push(x.slice(u5,u5+=s5));}return t5;}function startsWith(x,y){if(arguments.length===1)return v5=>startsWith(x,v5);return y.startsWith(x);}function subtract(x,y){if(arguments.length===1)return w5=>subtract(x,w5);return x-y;}function T(){return!0;}function tail(x5){return drop(1,x5);}function take(y5,x){if(arguments.length===1)return z5=>take(y5,z5);if(typeof x==='string'){return x.slice(0,y5);}return baseSlice(x,0,y5);}function takeLast(A5,x){if(arguments.length===1)return B5=>takeLast(A5,B5);const C5=x.length;let D5=A5>C5?C5:A5;if(typeof x==='string'){return x.slice(C5-D5);}D5=C5-D5;return baseSlice(x,D5,C5);}function tap(fn,x){if(arguments.length===1)return F5=>tap(fn,F5);fn(x);return x;}function test(G5,H5){if(arguments.length===1)return I5=>test(G5,I5);return H5.search(G5)!==-1;}function times(fn,K5){if(arguments.length===1)return L5=>times(fn,L5);return map(fn,range(0,K5));}function toLower(x){return x.toLowerCase();}function toString(x){return x.toString();}function toUpper(x){return x.toUpperCase();}function trim(M5){return M5.trim();}function uniq(N5){let O5=-1;const P5=[];while(++O5<N5.length){const Q5=N5[O5];if(!contains(Q5,P5)){P5.push(Q5);}}return P5;}function uniqWith(fn,S5){if(arguments.length===1)return T5=>uniqWith(fn,T5);let U5=-1;const V5=S5.length,W5=[];while(++U5<S5.length){const X5=S5[U5],Y5=any(Z5=>fn(X5,Z5),W5);if(!Y5){W5.push(X5);}}return W5;}function update(a6,b6,c6){if(b6===void 0){return(d6,e6)=>update(a6,d6,e6);}else if(c6===void 0){return f6=>update(a6,b6,f6);}const g6=c6.concat();return g6.fill(b6,a6,a6+1);}function values(h6){const i6=[];for(const j6 in h6){i6.push(h6[j6]);}return i6;}function without(k6,l6){return reduce((m6,n6)=>!contains(n6,k6)?m6.concat(n6):m6,[],l6);}function zip(x,y){if(arguments.length===1)return o6=>zip(x,o6);return addIndex(reduce)((p6,q6,r6)=>y[r6]?p6.concat([[q6,y[r6]]]):p6,[],x);}function zipObj(x,y){if(arguments.length===1)return s6=>zipObj(x,s6);return x.reduce((t6,u6,i)=>{t6[u6]=y[i];return t6;},{});}export{add,addIndex,adjust,all,allPass,always,any,anyPass,append,c1 as assoc,both,complement,compose,concat,contains,curry,dec,defaultTo,dissoc,divide,drop,dropLast,either,endsWith,equals,F,filter,find,findIndex,flatten,flip,forEach,groupBy,has,head,identity,ifElse,inc,includes,indexBy,indexOf,init,is,isNil,join,keys,last,lastIndexOf,length,map,match,merge,max,maxBy,min,y3 as minBy,modulo,multiply,none,not,nth,omit,partialCurry,path,c4 as pathOr,pick,pickAll,pipe,pluck,prepend,prop,propEq,range,reduce,reject,repeat,replace,reverse,sort,sortBy,split,splitEvery,startsWith,subtract,T,tail,take,takeLast,tap,test,times,toLower,toString,toUpper,trim,type,uniq,uniqWith,update,values,without,zip,zipObj};","export const WORDS = /[A-Z]?[a-z]+|[A-Z]+(?![a-z])+/g\nexport const WORDS_EXTENDED = /[A-Z\\xC0-\\xD6\\xD8-\\xDEА-Я]?[a-z\\xDF-\\xF6\\xF8-\\xFFа-я]+|[A-Z\\xC0-\\xD6\\xD8-\\xDE]+(?![a-z\\xDF-\\xF6\\xF8-\\xFF])/g\nexport const PUNCTUATIONSX = /[\",\\.\\?]/g\nexport const PUNCTUATIONS = /[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,\\-./:;<=>?@[\\]^_`{|}~]/g\nexport const HTML_TAGS = /<[^>]*>/g\n","import { match } from 'rambda'\nimport { WORDS } from './internals/constants'\n\nexport function words(str){\n  return match(WORDS, str)\n}\n","import { match } from 'rambda'\nimport { WORDS_EXTENDED } from './internals/constants'\n\nexport function wordsX(str){\n  return match(WORDS_EXTENDED, str)\n}\n","import {\n  join,\n  map,\n  toUpper,\n  head,\n  toLower,\n  tail,\n} from 'rambda'\n\nimport { words } from './words'\nimport { wordsX } from './wordsX'\n\nexport function camelCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  const result = join(\n    '',\n    map(\n      val => `${ toUpper(head(val)) }${ toLower(tail(val)) }`,\n      method(str)\n    )\n  )\n\n  return `${ toLower(head(result)) }${ tail(result) }`\n}\n","import {\n  length,\n  split,\n} from 'rambda'\n\nexport function count(str, substr){\n  return length(split(substr, str)) - 1\n}\n","import { words } from './words'\nimport {\n  compose,\n  toUpper,\n  join,\n  map,\n} from 'rambda'\nimport { wordsX } from './wordsX'\n  \nexport const constantCase = (str, extraLatin = false) => {\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  return compose(\n   join('_'),\n   map(toUpper),\n   method\n )(str)\n}\n\n","export function distance(a, b){\n  if (a.length === 0){ return b.length }\n  if (b.length === 0){ return a.length }\n  let i, j, prev, tmp, val\n\n  if (a.length > b.length){\n    tmp = a\n    a = b\n    b = tmp\n  }\n\n  const row = Array(a.length + 1)\n\n  for (i = 0; i <= a.length; i++){\n    row[ i ] = i\n  }\n\n  for (i = 1; i <= b.length; i++){\n    prev = i\n    for (j = 1; j <= a.length; j++){\n      if (b[ i - 1 ] === a[ j - 1 ]){\n        val = row[ j - 1 ]\n      } else {\n        val = Math.min(\n          row[ j - 1 ] + 1,\n          Math.min(\n            prev + 1,\n            row[ j ] + 1\n          )\n        )\n      }\n      row[ j - 1 ] = prev\n      prev = val\n    }\n    row[ a.length ] = prev\n  }\n\n  return row[ a.length ]\n}\n","import {\n  map,\n  split,\n  join,\n  toLower,\n} from 'rambda'\nimport { distance } from './distance'\n\nconst normalizeGermanChar = char => {\n  const arr = [ 'ä', 'ö', 'ü', 'ß' ]\n  const normalizedArr = [ 'a', 'o', 'u', 'ss' ]\n  const foundIndex = arr.indexOf(char)\n\n  if (foundIndex === -1){\n    return char\n  }\n\n  return normalizedArr[ foundIndex ]\n}\n\nconst normalizeGermanWord = str => join(\n  '',\n  map(\n    val => normalizeGermanChar(val),\n    split('', toLower(str))\n  )\n)\n\nexport function distanceGerman(a, b){\n  return distance(normalizeGermanWord(a), normalizeGermanWord(b))\n}\n","import {\n  join,\n  map,\n  toLower,\n} from 'rambda'\nimport { words } from './words'\nimport { wordsX } from './wordsX'\n\nexport function dotCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  return join(\n    '.',\n    map(\n      toLower,\n      method(str)\n    )\n  )\n}\n","import {\n  head,\n  init,\n  last,\n  tail,\n} from 'rambda'\n\nimport { count } from './count'\n\nexport function glob(str, globStr){\n  const numGlobs = count(globStr, '*')\n\n  if (numGlobs === 1){\n    if (head(globStr) === '*'){\n      return str.endsWith(tail(globStr))\n    } else if (last(globStr) === '*'){\n      return str.startsWith(init(globStr))\n    }\n  } else if (\n    numGlobs === 2 &&\n    head(globStr) === '*' &&\n    last(globStr) === '*'\n  ){\n    globStr = init(tail(globStr))\n    const foundIndex = str.indexOf(globStr)\n\n    return foundIndex > 0 && foundIndex + globStr.length < str.length\n  }\n\n  return false\n}\n","import {\n  join,\n  map,\n  split,\n} from 'rambda'\n\nexport function indent(str, indentCount){\n  return join(\n    '\\n',\n    map(\n      val => `${ ' '.repeat(indentCount) }${ val }`,\n      split('\\n', str)\n    )\n  )\n}\n","import { test } from 'rambda'\nimport { WORDS_EXTENDED } from './internals/constants'\n\nexport function isLetter(char){\n  return test(WORDS_EXTENDED, char)\n}\n","import { test } from 'rambda'\nimport { PUNCTUATIONS } from './internals/constants'\n\nexport function isPunctuation(char){\n  return test(PUNCTUATIONS, char)\n}\n","import { words } from './words'\nimport {\n  toLower,\n  join,\n} from 'rambda'\nimport { wordsX } from './wordsX'\n\nexport function kebabCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  return toLower(join(\n    '-',\n    method(str)\n  ))\n}\n","import { replace } from 'rambda'\n\nexport function trim(str){\n  return replace(/\\s+/g, ' ', str).trim()\n}\n","import {\n  test,\n  head,\n  last,\n} from 'rambda'\nimport { PUNCTUATIONSX } from './constants'\n\nconst humanLengths = {\n  5 : 'Five',\n  6 : 'Six',\n  7 : 'Seven',\n  8 : 'Eight',\n}\n\nconst globs = {\n  easyFive     : '*123*',\n  easySix      : '*123**',\n  easySixR     : '**234*',\n  easierSix    : '*123**',\n  easierSixR   : '**234*',\n  easySeven    : '*1234**',\n  easySevenR   : '**2345*',\n  easierSeven  : '**234**',\n  easyEight    : '**2345**',\n  easierEight  : '**234***',\n  easierEightR : '***345**',\n  easyAny      : len => `**${ '-'.repeat(len - 5) }***`,\n  easierAny    : len => `***${ '-'.repeat(len - 6) }***`,\n}\n\nfunction chance(){\n  return Math.random() > 0.49\n}\n\nfunction getGlob(len, mode, random){\n  if (len > 8) return globs[ `${ mode }Any` ](len)\n  if (len === 5) return globs.easyFive\n  const base = `${ mode }${ humanLengths[ len ] }`\n  const maybeKey = globs[ base ]\n\n  if (!random){\n    return maybeKey === undefined ?\n      globs[ `easy${ humanLengths[ len ] }` ] :\n      maybeKey\n  }\n\n  return globs[ `${ base }R` ] === undefined ?\n    maybeKey :\n    chance() ?\n      globs[ `${ base }R` ] :\n      maybeKey\n}\n\nexport function ant(word, glob, replacer){\n  const chars = [ ...word ]\n\n  return chars.map((char, i) => glob[ i ] === '*' ?\n    char :\n    replacer\n  ).join('')\n}\n\nexport function maskWordHelper(word, replacer, charLimit = 4){\n  if (\n    test(PUNCTUATIONSX, word) ||\n    word.length <= 1\n  ){\n    return word\n  }\n\n  if (word.length < charLimit){\n    return `${ head(word) }${ replacer.repeat(word.length - 1) }`\n  }\n\n  return `${ head(word) }${ replacer.repeat(word.length - 2) }${ last(word) }`\n}\n\nexport function maskWordHelperX({\n  word,\n  replacer = '_',\n  easyMode = false,\n  randomMode = false,\n  easierMode = false,\n  charLimit = 4,\n}){\n  const len = word.length\n  if (\n    !easyMode && !easierMode ||\n    len <= 4\n  ) return maskWordHelper(word, replacer, charLimit)\n\n  const glob = getGlob(\n    len,\n    easyMode ? 'easy' : 'easier',\n    randomMode\n  )\n\n  return ant(word, glob, replacer)\n}\n","import { trim } from './trim'\nimport { maskWordHelper, maskWordHelperX } from './internals/maskWordHelper'\nimport { PUNCTUATIONSX } from './internals/constants'\n\nimport {\n  partialCurry,\n  map,\n  split,\n} from 'rambda'\n\nconst addSpaceAroundPunctuation = sentence =>\n  sentence.replace(PUNCTUATIONSX, x => ` ${ x } `)\n\n/**\n * Use shorter version of PUNCTUATIONS so_\n * cases `didn't` and `по-добри` be handled\n */\nexport function maskSentence({\n  charLimit = 4,\n  easyMode = false,\n  easierMode = false,\n  randomMode = false,\n  replacer = '_',\n  sentence,\n  words = [],\n}){\n  const parsed = trim(addSpaceAroundPunctuation(sentence))\n  const hidden = []\n  const visible = []\n  const input = {\n    replacer,\n    easyMode,\n    randomMode,\n    easierMode,\n    charLimit,\n  }\n  const easyFn = partialCurry(maskWordHelperX, input)\n  const ant = easierMode || easyMode ?\n    word => easyFn({ word }) :\n    word => maskWordHelper(word, replacer, charLimit)\n\n  map(\n    word => {\n      const ok =\n        words.length === 0 ||\n        words.includes(word)\n\n      const visiblePart = ok ?\n        ant(word) :\n        word\n\n      hidden.push(word)\n      visible.push(visiblePart)\n    },\n    split(' ', parsed)\n  )\n\n  return {\n    hidden,\n    visible,\n  }\n}\n","import { maskWordHelper } from './internals/maskWordHelper'\nimport { split, join, map } from 'rambda'\n\nexport function maskWords({ words, replacer = '_', charLimit = 3 }){\n  const result = map(\n    val => maskWordHelper(val, replacer, charLimit),\n    split(' ', words)\n  )\n\n  return join(' ', result)\n}\n","function parseInput(inputRaw){\n  if (typeof inputRaw !== 'string') throw new Error('inputRaw !== string')\n\n  const numbers = []\n  const chars = []\n  let flag = false\n\n  inputRaw.split('').forEach(x => {\n    if (flag && x){\n\n      chars.push(x)\n    } else if (!flag){\n\n      const isNumber = Number(x) === Number(x)\n\n      if (isNumber){\n\n        numbers.push(x)\n      } else {\n\n        chars.push(x)\n        flag = true\n      }\n\n    } else {\n\n      flag = true\n    }\n  })\n\n  return {\n    numbers : Number(numbers.join('')),\n    chars   : chars.join(''),\n  }\n}\n\nconst hash = {\n  1     : [ 's', 'seconds', 'second', 'sec' ],\n  60    : [ 'm', 'minutes', 'minute', 'min' ],\n  3600  : [ 'h', 'hours', 'hour' ],\n  86400 : [ 'd', 'days', 'day' ],\n}\n\nfunction findInHash(hashKey){\n  const [ found ] = Object.keys(hash).filter(singleKey => hash[ singleKey ].includes(hashKey))\n\n  if (!found) throw new Error('no numbers passed to `ms`')\n\n  return found\n}\n\nexport function ms(inputRaw){\n  const input = parseInput(inputRaw)\n\n  const miliseconds = findInHash(input.chars)\n\n  return Math.floor(Number(miliseconds) * 1000 * input.numbers)\n}\n","import {\n  join,\n  map,\n  toUpper,\n  head,\n  toLower,\n  tail,\n} from 'rambda'\nimport { words } from './words'\nimport { wordsX } from './wordsX'\n\nexport function pascalCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  return join(\n    '',\n    map(\n      val => `${ toUpper(head(val)) }${ toLower(tail(val)) }`,\n      method(str)\n    )\n  )\n}\n","import {\n  join,\n  map,\n  split,\n} from 'rambda'\n\nexport function removeIndent(str){\n  return join(\n    '\\n',\n    map(\n      val => val.trimLeft(),\n      split('\\n', str)\n    )\n  )\n}\n","export function reverse(str){\n  return [ ...str ].reverse().join('')\n}\n","import {\n  join,\n  map,\n  toUpper,\n  toLower,\n  head,\n  tail,\n} from 'rambda'\nimport { words } from './words'\n\nexport function seoTitle(str, limit = 3){\n  const result = join(\n    ' ',\n    map(\n      val => {\n        if (val.length >= limit){\n          return `${ toUpper(head(val)) }${ toLower(tail(val)) }`\n        }\n\n        return val\n      },\n      words(str)\n    )\n  )\n\n  return `${ toUpper(head(result)) }${ tail(result) }`\n}\n","import {\n  join,\n  split,\n} from 'rambda'\n\nconst shuffleArr = arr => {\n  let counter = arr.length\n  while (counter > 0){\n    const index = Math.floor(Math.random() * counter)\n    counter--\n    const temp = arr[ counter ]\n    arr[ counter ] = arr[ index ]\n    arr[ index ] = temp\n  }\n\n  return arr\n}\n\nexport function shuffle(str){\n  return join(\n    '',\n    shuffleArr(\n      split('', str)\n    )\n  )\n}\n","import {\n  toLower,\n  join,\n} from 'rambda'\nimport { words } from './words'\nimport { wordsX } from './wordsX'\n\nexport function snakeCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n\n  return toLower(\n    join(\n      '_',\n      method(str)\n    )\n  )\n}\n","import { head } from 'rambda'\nfunction workingMan(partialSplitted, perLine){\n  let lengthHolder = 0\n  let counter = -1\n  let didOverflow = false\n  const willReturn = []\n  const len = partialSplitted.length\n  const overTheTop = head(partialSplitted).length >= perLine\n\n  while (lengthHolder < perLine && counter + 1 < len){\n    counter++\n    const currentInstance = partialSplitted[ counter ]\n    const mystery = lengthHolder + currentInstance.length + 1\n\n    if (mystery > perLine){\n\n      didOverflow = true\n      if(overTheTop) willReturn.push(currentInstance)\n    } else {\n\n      willReturn.push(currentInstance)\n    }\n\n    lengthHolder = mystery\n  }\n\n  const okCounter = counter - len + 1 === 0\n\n  const isOver = didOverflow ?\n    overTheTop :\n    okCounter\n\n  const newPartialSplitted = partialSplitted.slice(willReturn.length)\n\n  return {\n    end                : isOver,\n    readyForPush       : willReturn,\n    newPartialSplitted : newPartialSplitted,\n  }\n}\n\nexport function splitPerLine({\n  text,\n  splitChar = ' ',\n  perLine = 30,\n}){\n  const willReturn = []\n  let counter = -1\n  let splitted = text.split(splitChar)\n  const len = splitted.length\n\n  while (counter++ < len){\n    const {\n      end,\n      newPartialSplitted,\n      readyForPush,\n    } = workingMan(splitted, perLine)\n\n    willReturn.push(readyForPush)\n\n    if (end){\n\n      counter = len\n    } else {\n\n      splitted = newPartialSplitted\n    }\n  }\n  const parsed = willReturn.map(singleAnswer => singleAnswer.join(splitChar))\n\n  return parsed\n}\n\n","import { split } from 'rambda'\nimport { trim } from './trim'\nimport { PUNCTUATIONS } from './internals/constants'\n\nconst addSpaceAroundPunctuation = sentence =>\n  sentence.replace(\n    PUNCTUATIONS,\n    match => ` ${ match } `\n  )\n\nexport function splitSentence(sentence){\n  return split(\n    ' ',\n    trim(\n      addSpaceAroundPunctuation(sentence)\n    )\n  )\n}\n","import { replace } from 'rambda'\nimport { PUNCTUATIONS } from './internals/constants'\n\nexport function stripPunctuation(str){\n  return replace(PUNCTUATIONS, '', str)\n}\n","function type(a) {\n  const typeOf = typeof a;\n\n  if (a === null) {\n    return 'Null';\n  } else if (a === undefined) {\n    return 'Undefined';\n  } else if (typeOf === 'boolean') {\n    return 'Boolean';\n  } else if (typeOf === 'number') {\n    return 'Number';\n  } else if (typeOf === 'string') {\n    return 'String';\n  } else if (Array.isArray(a)) {\n    return 'Array';\n  } else if (a instanceof RegExp) {\n    return 'RegExp';\n  }\n\n  const asStr = a.toString();\n\n  if (asStr.startsWith('async')) {\n    return 'Async';\n  } else if (asStr === '[object Promise]') {\n    return 'Promise';\n  } else if (asStr.includes('function') || asStr.includes('=>')) {\n    return 'Function';\n  }\n\n  return 'Object';\n}\n\nfunction allFalse(...inputs) {\n  let counter = 0;\n\n  while (counter < inputs.length) {\n    const x = inputs[counter];\n\n    if (type(x) === 'Function') {\n      if (inputs[counter]()) {\n        return false;\n      }\n    } else if (inputs[counter]) {\n      return false;\n    }\n\n    counter++;\n  }\n\n  return true;\n}\n\nfunction allTrue(...inputs) {\n  let counter = 0;\n  while (counter < inputs.length) {\n    const x = inputs[counter];\n\n    if (type(x) === 'Function') {\n      if (!inputs[counter]()) {\n        return false;\n      }\n    } else if (!inputs[counter]) {\n      return false;\n    }\n\n    counter++;\n  }\n\n  return true;\n}\n\nfunction allType(targetType) {\n  return (...inputs) => {\n    let counter = 0;\n\n    while (counter < inputs.length) {\n      if (type(inputs[counter]) !== targetType) {\n        return false;\n      }\n      counter++;\n    }\n\n    return true;\n  };\n}\n\nfunction anyFalse(...inputs) {\n  let counter = 0;\n  while (counter < inputs.length) {\n    if (!inputs[counter]) {\n      return true;\n    }\n    counter++;\n  }\n\n  return false;\n}\n\nfunction anyTrue(...inputs) {\n  let counter = 0;\n  while (counter < inputs.length) {\n    if (inputs[counter]) {\n      return true;\n    }\n    counter++;\n  }\n\n  return false;\n}\n\nfunction anyType(targetType) {\n  return (...inputs) => {\n    let counter = 0;\n\n    while (counter < inputs.length) {\n      if (type(inputs[counter]) === targetType) {\n        return true;\n      }\n      counter++;\n    }\n\n    return false;\n  };\n}\n\n/**Used as the `TypeError` message for \"Functions\" methods. */\nconst FUNC_ERROR_TEXT = 'Expected a function';\n\n/**Used to stand-in for `undefined` hash values. */\nconst HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**Used as references for various `Number` constants. */\nlet INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/**`Object#toString` result references. */\nlet funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/**Used to match property names within property paths. */\nlet reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/**Used to match backslashes in property paths. */\nconst reEscapeChar = /\\\\(\\\\)?/g;\n\n/**Used to detect host constructors (Safari). */\nconst reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**Used to detect unsigned integer values. */\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**Detect free variable `global` from Node.js. */\nconst freeGlobal = typeof global === 'object' && global && global.Object === Object && global;\n\n/**Detect free variable `self`. */\nconst freeSelf = typeof self === 'object' && self && self.Object === Object && self;\n\n/**Used as a reference to the global object. */\nconst root = freeGlobal || freeSelf || /*#__PURE__*/Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  //Many host objects are `Object` objects that can coerce to strings\n  //despite having improperly defined `toString` methods.\n  let result = false;\n  if (value != null && typeof value.toString !== 'function') {\n    try {\n      result = Boolean(String(value));\n    } catch (e) {}\n  }\n\n  return result;\n}\n\n/**Used for built-in method references. */\nlet arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/**Used to detect overreaching core-js shims. */\nconst coreJsData = root['__core-js_shared__'];\n\n/**Used to detect methods masquerading as native. */\nconst maskSrcKey = /*#__PURE__*/function () {\n  const uid = /*#__PURE__*//[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\n  return uid ? 'Symbol(src)_1.' + uid : '';\n}();\n\n/**Used to resolve the decompiled source of functions. */\nconst funcToString = funcProto.toString;\n\n/**Used to check objects for own properties. */\nconst hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nconst objectToString = objectProto.toString;\n\n/**Used to detect if a method is native. */\nconst reIsNative = /*#__PURE__*/RegExp('^' + /*#__PURE__*/funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n\n/**Built-in value references. */\nlet Symbol$1 = root.Symbol,\n    splice = arrayProto.splice;\n\n/*Built-in method references that are verified to be native. */\nlet Map = /*#__PURE__*/getNative(root, 'Map'),\n    nativeCreate = /*#__PURE__*/getNative(Object, 'create');\n\n/**Used to convert symbols to primitives and strings. */\nlet symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  let index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    const entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  const data = this.__data__;\n  if (nativeCreate) {\n    const result = data[key];\n\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  const data = this.__data__;\n\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  const data = this.__data__;\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n\n  return this;\n}\n\n//Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype.delete = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  let index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    const entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  let data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  const lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  let data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  let data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n\n  return this;\n}\n\n//Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype.delete = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  let index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    const entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    hash: new Hash(),\n    map: new (Map || ListCache)(),\n    string: new Hash()\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key).delete(key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n\n  return this;\n}\n\n//Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype.delete = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  const objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  let length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  const pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\n\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  let index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    let key = toKey(path[index]),\n        newValue = value;\n\n    if (index != lastIndex) {\n      const objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n\n  return object;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  //Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  const result = String(value);\n\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  const data = map.__data__;\n\n  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  const value = getValue(object, key);\n\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return Boolean(length) && (typeof value === 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  const type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  const type = typeof value;\n\n  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return Boolean(maskSrcKey) && maskSrcKey in func;\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = /*#__PURE__*/memoize(string => {\n  string = toString(string);\n\n  const result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, (match, number, quote, string) => {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value === 'string' || isSymbol(value)) {\n    return value;\n  }\n  const result = String(value);\n\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return String(func);\n    } catch (e) {}\n  }\n\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func !== 'function' || resolver && typeof resolver !== 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function () {\n    let args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache)();\n\n  return memoized;\n}\n\n//Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  //The use of `Object#toString` avoids issues with the `typeof` operator\n  //in Safari 8-9 which returns 'object' for typed array and other constructors.\n  const tag = isObject(value) ? objectToString.call(value) : '';\n\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return Boolean(value) && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return Boolean(value) && typeof value === 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value === 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nfunction whenObject(rule, hash) {\n  const yes = {};\n  const no = {};\n  Object.entries(hash).forEach(([prop, value]) => {\n    if (rule(value, prop)) {\n      yes[prop] = value;\n    } else {\n      no[prop] = value;\n    }\n  });\n\n  return [yes, no];\n}\n\nfunction partition(rule, list) {\n  if (arguments.length === 1) {\n    return listHolder => partition(rule, listHolder);\n  }\n  if (!Array.isArray(list)) return whenObject(rule, list);\n\n  const yes = [];\n  const no = [];\n  let counter = -1;\n\n  while (counter++ < list.length - 1) {\n    if (rule(list[counter], counter)) {\n      yes.push(list[counter]);\n    } else {\n      no.push(list[counter]);\n    }\n  }\n\n  return [yes, no];\n}\n\n//Its lodash's set method taken from\n\nconst isObject$1 = x => {\n  const ok = x !== null && !Array.isArray(x) && typeof x === 'object';\n  if (!ok) {\n    return false;\n  }\n\n  return Object.keys(x).length > 0;\n};\n\nfunction change(origin, pathRaw, rules) {\n  const willReturn = JSON.parse(JSON.stringify(origin));\n\n  if (!isObject$1(rules)) {\n    set(willReturn, pathRaw, rules);\n\n    return willReturn;\n  }\n  const path = pathRaw === '' ? '' : `${pathRaw}.`;\n\n  for (const ruleKey of Object.keys(rules)) {\n    const rule = rules[ruleKey];\n    if (!isObject$1(rule)) {\n      set(willReturn, `${path}${ruleKey}`, rule);\n      continue;\n    }\n    const [withObjects, withoutObjects] = partition(subruleKey => isObject$1(rule[subruleKey]), Object.keys(rule));\n\n    withoutObjects.forEach(subruleKey => {\n      const subrule = rule[subruleKey];\n      set(willReturn, `${path}${ruleKey}.${subruleKey}`, subrule);\n    });\n\n    withObjects.forEach(subruleKey => {\n      const subrule = rule[subruleKey];\n      Object.keys(subrule).forEach(deepKey => {\n        const deep = rule[subruleKey][deepKey];\n\n        if (!isObject$1(deep)) {\n          return set(willReturn, `${path}${ruleKey}.${subruleKey}.${deepKey}`, deep);\n        }\n\n        Object.keys(deep).forEach(superDeepKey => {\n          const superDeep = rule[subruleKey][deepKey][superDeepKey];\n\n          set(willReturn, `${path}${ruleKey}.${subruleKey}.${deepKey}.${superDeepKey}`, superDeep);\n        });\n      });\n    });\n  }\n\n  return willReturn;\n}\n\nfunction composeAsync(...inputArguments) {\n  return async function (startArgument) {\n    let argumentsToPass = startArgument;\n\n    while (inputArguments.length !== 0) {\n      const fn = inputArguments.pop();\n      const typeFn = type(fn);\n\n      if (typeFn === 'Async') {\n        argumentsToPass = await fn(argumentsToPass);\n      } else {\n        argumentsToPass = fn(argumentsToPass);\n      }\n    }\n\n    return argumentsToPass;\n  };\n}\n\nfunction compose(...fns) {\n  return (...args) => {\n    const list = fns.slice();\n    if (list.length > 0) {\n      const fn = list.pop();\n      let result = fn(...args);\n      while (list.length > 0) {\n        result = list.pop()(result);\n      }\n\n      return result;\n    }\n\n    return undefined;\n  };\n}\n\nfunction last(a) {\n  if (typeof a === 'string') {\n    return a[a.length - 1] || '';\n  }\n\n  return a[a.length - 1];\n}\n\nfunction baseSlice(array, start, end) {\n  let index = -1;\n  let length = array.length;\n\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n\n  const result = Array(length);\n\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n\n  return result;\n}\n\nfunction init(a) {\n  if (typeof a === 'string') {\n    return a.slice(0, -1);\n  }\n\n  return a.length ? baseSlice(a, 0, -1) : [];\n}\n\nfunction composed(...inputs) {\n  return compose(...init(inputs))(last(inputs));\n}\n\nfunction equals(a, b) {\n  if (arguments.length === 1) {\n    return bHolder => equals(a, bHolder);\n  }\n\n  if (a === b) {\n    return true;\n  }\n\n  const aType = type(a);\n\n  if (aType !== type(b)) {\n    return false;\n  }\n\n  if (aType === 'Array') {\n    const aClone = Array.from(a);\n    const bClone = Array.from(b);\n\n    if (aClone.toString() !== bClone.toString()) {\n      return false;\n    }\n\n    let loopArrayFlag = true;\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag) {\n        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {\n          loopArrayFlag = false;\n        }\n      }\n    });\n\n    return loopArrayFlag;\n  }\n\n  if (aType === 'Object') {\n    const aKeys = Object.keys(a);\n\n    if (aKeys.length !== Object.keys(b).length) {\n      return false;\n    }\n\n    let loopObjectFlag = true;\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag) {\n        const aValue = a[aKeyInstance];\n        const bValue = b[aKeyInstance];\n\n        if (aValue !== bValue && !equals(aValue, bValue)) {\n          loopObjectFlag = false;\n        }\n      }\n    });\n\n    return loopObjectFlag;\n  }\n\n  return false;\n}\n\n// NODOCS\nfunction count(target, list) {\n  if (arguments.length === 1) {\n    return listHolder => count(target, listHolder);\n  }\n  if (!Array.isArray(list)) return 0;\n\n  return list.filter(x => equals(x, target)).length;\n}\n\nfunction debounce(func, ms, immediate = false) {\n  let timeout;\n\n  return function (...input) {\n    const later = function () {\n      timeout = null;\n      if (!immediate) {\n        func.apply(null, input);\n      }\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, ms);\n    if (callNow) {\n      func.apply(null, input);\n    }\n  };\n}\n\nfunction flagIs(targetType, input) {\n  if (!input) return false;\n  if (type(input) !== targetType) return false;\n\n  if (targetType === 'Array') return !equals([], input);\n  if (targetType === 'Object') return !equals({}, input);\n\n  return true;\n}\n\nfunction defaultToStrict(defaultArgument, ...inputArguments) {\n  if (arguments.length === 1) {\n    return inputArgumentsHolder => defaultToStrict(defaultArgument, inputArgumentsHolder);\n  }\n  if (arguments.length === 2) {\n    return flagIs(type(defaultArgument), inputArguments[0]) ? inputArguments[0] : defaultArgument;\n  }\n\n  const targetType = type(defaultArgument);\n  const limit = inputArguments.length - 1;\n  let len = limit + 1;\n  let ready = false;\n  let holder;\n\n  while (!ready) {\n    const instance = inputArguments[limit - len + 1];\n\n    if (len === 0) {\n      ready = true;\n    } else if (flagIs(targetType, instance)) {\n      holder = instance;\n      ready = true;\n    } else {\n      len -= 1;\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder;\n}\n\nfunction defaultToWhen(defaultArgument, fn, ...inputArguments) {\n  if (arguments.length === 2) {\n    return (...inputArgumentsHolder) => defaultToWhen(defaultArgument, fn, ...inputArgumentsHolder);\n  }\n\n  const limit = inputArguments.length - 1;\n  let len = limit + 1;\n  let ready = false;\n  let holder;\n\n  while (!ready) {\n    const instance = inputArguments[limit - len + 1];\n\n    if (len === 0) {\n      ready = true;\n    } else if (fn(instance) === true) {\n      holder = instance;\n      ready = true;\n    } else {\n      len = len - 1;\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder;\n}\n\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('RAMBDAX_DELAY');\n    }, ms);\n  });\n}\n\nfunction findInObject(fn, obj) {\n  if (arguments.length === 1) {\n    return objHolder => findInObject(fn, objHolder);\n  }\n  let willReturn = { fallback: true };\n\n  Object.entries(obj).forEach(([prop, value]) => {\n    if (willReturn.fallback) {\n      if (fn(value, prop)) {\n        willReturn = {\n          prop,\n          value\n        };\n      }\n    }\n  });\n\n  return willReturn;\n}\n\n//WAIT\nfunction findModify(fn, list) {\n  if (arguments.length === 1) {\n    return listHolder => findModify(fn, listHolder);\n  }\n\n  const len = list.length;\n  if (len === 0) return false;\n\n  let index = -1;\n\n  while (++index < len) {\n    const result = fn(list[index], index);\n    if (result !== false) {\n      return result;\n    }\n  }\n\n  return false;\n}\n\nfunction flatMap(fn, xs) {\n  if (arguments.length === 1) {\n    return xsHolder => flatMap(fn, xsHolder);\n  }\n\n  return [].concat(...xs.map(fn));\n}\n\nfunction pick(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pick(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction merge(obj, newProps) {\n  if (arguments.length === 1) {\n    return newPropsHolder => merge(obj, newPropsHolder);\n  }\n\n  return Object.assign({}, obj || {}, newProps || {});\n}\n\nlet holder = {};\n\n/**\n * Pass string to get value\n * Pass array to get object of values\n * Pass undefined to get all data\n */\nfunction getter(key) {\n  const typeKey = type(key);\n\n  if (typeKey === 'String') return holder[key];\n\n  if (typeKey === 'Array') return pick(key, holder);\n\n  return holder;\n}\n\nfunction setter(maybeKey, maybeValue) {\n  const typeKey = type(maybeKey);\n  const typeValue = type(maybeValue);\n\n  if (typeKey === 'String') {\n    if (typeValue === 'Function') {\n      return holder[maybeKey] = maybeValue(holder[maybeKey]);\n    }\n\n    return holder[maybeKey] = maybeValue;\n  }\n\n  if (typeKey !== 'Object') return;\n\n  holder = merge(holder, maybeKey);\n}\n\nfunction reset() {\n  holder = {};\n}\n\nfunction glue(input, glue) {\n  return input.split('\\n').filter(x => x.trim().length > 0).map(x => x.trim()).join(glue !== undefined ? glue : ' ');\n}\n\nfunction createThenable(x) {\n  return async function (input) {\n    return x(input);\n  };\n}\n\nfunction ifElseAsync(condition, ifFn, elseFn) {\n  return input => new Promise((resolve, reject) => {\n    const conditionPromise = createThenable(condition);\n    const ifFnPromise = createThenable(ifFn);\n    const elseFnPromise = createThenable(elseFn);\n\n    conditionPromise(input).then(conditionResult => {\n      const promised = conditionResult === true ? ifFnPromise : elseFnPromise;\n\n      promised(input).then(resolve).catch(reject);\n    }).catch(reject);\n  });\n}\n\nfunction any(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => any(fn, arrHolder);\n  }\n\n  let counter = 0;\n  while (counter < arr.length) {\n    if (fn(arr[counter], counter)) {\n      return true;\n    }\n    counter++;\n  }\n\n  return false;\n}\n\nfunction expensiveIncludes(target, source) {\n  return any(singleSource => equals(target, singleSource), source);\n}\n\nfunction includesAny(targets, source) {\n  if (arguments.length === 1) {\n    return sourceHolder => includesAny(targets, sourceHolder);\n  }\n  const sourceType = type(source);\n\n  if (['Array', 'String'].includes(sourceType) === false) {\n    return false;\n  }\n\n  if (sourceType === 'String') {\n    return any(x => source.includes(x), targets);\n  }\n\n  return any(x => expensiveIncludes(x, source), targets);\n}\n\nfunction includesType(targetType, list) {\n  if (arguments.length === 1) {\n    return listHolder => includesType(targetType, listHolder);\n  }\n\n  return any(x => type(x) === targetType, list);\n}\n\nfunction replace(regex, replacer, str) {\n  if (replacer === undefined) {\n    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);\n  } else if (str === undefined) {\n    return strHolder => replace(regex, replacer, strHolder);\n  }\n\n  return str.replace(regex, replacer);\n}\n\nfunction inject(injection, marker, content) {\n  return replace(marker, `${marker}${injection}`, content);\n}\n\nfunction take(num, x) {\n  if (arguments.length === 1) return xHolder => take(num, xHolder);\n\n  if (typeof x === 'string') {\n    return x.slice(0, num);\n  }\n\n  return baseSlice(x, 0, num);\n}\n\nfunction shuffle(arrayRaw) {\n  const array = arrayRaw.concat();\n  let counter = array.length;\n  while (counter > 0) {\n    const index = Math.floor(Math.random() * counter);\n    counter--;\n    const temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n\n  return array;\n}\n\n// NODOCS\nconst uuidList = /*#__PURE__*/'0123456789qwertyuiopasdfghjklzxcvbnm'.split('');\n\nfunction uuid() {\n  return take(5, shuffle(uuidList).join(''));\n}\n\nconst holder$1 = {};\n\nfunction interval({ fn, ms, whenStop }) {\n  const key = uuid();\n  return new Promise(resolve => {\n    holder$1[key] = setInterval(() => {\n      if (whenStop() === true) {\n        clearInterval(holder$1[key]);\n        resolve();\n      } else {\n        fn();\n      }\n    }, ms);\n  });\n}\n\nfunction toLower(x) {\n  return x.toLowerCase();\n}\n\nfunction contains(x, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => contains(x, arrHolder);\n  }\n\n  let index = -1;\n  let flag = false;\n\n  while (++index < arr.length && !flag) {\n    if (equals(arr[index], x)) {\n      flag = true;\n    }\n  }\n\n  return flag;\n}\n\nfunction test$1(regex, str) {\n  if (arguments.length === 1) return strHolder => test$1(regex, strHolder);\n\n  return str.search(regex) !== -1;\n}\n\nfunction filterObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    if (fn(obj[prop], prop)) {\n      willReturn[prop] = obj[prop];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction filter(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => filter(fn, arrHolder);\n  }\n\n  if (arr === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(arr)) {\n    return filterObject(fn, arr);\n  }\n\n  let index = -1;\n  let resIndex = 0;\n  const len = arr.length;\n  const willReturn = [];\n\n  while (++index < len) {\n    const value = arr[index];\n\n    if (fn(value, index)) {\n      willReturn[resIndex++] = value;\n    }\n  }\n\n  return willReturn;\n}\n\nfunction all(condition, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => all(condition, arrHolder);\n  }\n\n  return filter(condition, arr).length === arr.length;\n}\n\nfunction fromPrototypeToString(rule, ruleType) {\n  if (ruleType !== 'Function') return {\n    rule,\n    parsed: false\n  };\n  if (typeof rule.prototype === 'function' || rule.prototype === undefined) {\n    return {\n      rule,\n      parsed: false\n    };\n  }\n  if (String.prototype === rule.prototype) {\n    return {\n      rule: 'string',\n      parsed: true\n    };\n  }\n  if (Boolean.prototype === rule.prototype) {\n    return {\n      rule: 'boolean',\n      parsed: true\n    };\n  }\n  if (Number.prototype === rule.prototype) {\n    return {\n      rule: 'number',\n      parsed: true\n    };\n  }\n\n  return {\n    rule: type(rule.prototype).toLowerCase(),\n    parsed: true\n  };\n}\n\nfunction getRuleAndType(schema, requirementRaw) {\n  const ruleRaw = schema[requirementRaw];\n  const typeIs = type(ruleRaw);\n  const { rule, parsed } = fromPrototypeToString(ruleRaw, typeIs);\n\n  return {\n    rule: rule,\n    ruleType: parsed ? 'String' : typeIs\n  };\n}\n\nfunction isValid({ input, schema }) {\n  if (input === undefined || schema === undefined) return false;\n\n  let flag = true;\n  const boom = boomFlag => {\n    if (!boomFlag) {\n      flag = false;\n    }\n  };\n\n  for (const requirementRaw in schema) {\n    if (flag) {\n      const isOptional = requirementRaw.endsWith('?');\n      const requirement = isOptional ? init(requirementRaw) : requirementRaw;\n\n      const { rule, ruleType } = getRuleAndType(schema, requirementRaw);\n      const inputProp = input[requirement];\n      const inputPropType = type(input[requirement]);\n\n      const ok = isOptional && inputProp !== undefined || !isOptional;\n\n      if (!ok || rule === 'any' && inputProp != null || rule === inputProp) continue;\n\n      if (ruleType === 'Object') {\n        /**\n         * This rule is standalone schema, so we recursevly call `isValid`\n         */\n        const isValidResult = isValid({\n          input: inputProp,\n          schema: rule\n        });\n        boom(isValidResult);\n      } else if (ruleType === 'String') {\n        /**\n         * Rule is actual rule such as 'number', so the two types are compared\n         */\n        boom(toLower(inputPropType) === rule);\n      } else if (typeof rule === 'function') {\n        /**\n         * Rule is function so we pass to it the input\n         */\n        boom(rule(inputProp));\n      } else if (ruleType === 'Array' && inputPropType === 'String') {\n        /**\n         * Enum case | rule is like a: ['foo', 'bar']\n         */\n        boom(contains(inputProp, rule));\n      } else if (ruleType === 'Array' && rule.length === 1 && inputPropType === 'Array') {\n        /**\n         * 1. array of type | rule is like a: ['number']\n         * 2. rule is like a: [{from: 'string'}]\n         */\n        const currentRule = rule[0];\n        const currentRuleType = type(rule[0]);\n        //Check if rule is invalid\n        boom(currentRuleType === 'String' || currentRuleType === 'Object');\n\n        if (currentRuleType === 'String') {\n          /**\n           * 1. array of type\n           */\n          const isInvalidResult = any(inputPropInstance => type(inputPropInstance).toLowerCase() !== currentRule, inputProp);\n          boom(!isInvalidResult);\n        }\n\n        if (currentRuleType === 'Object') {\n          /**\n           * 2. rule is like a: [{from: 'string'}]\n           */\n          const isValidResult = all(inputPropInstance => isValid({\n            input: inputPropInstance,\n            schema: currentRule\n          }), inputProp);\n          boom(isValidResult);\n        }\n      } else if (ruleType === 'RegExp' && inputPropType === 'String') {\n        boom(test$1(rule, inputProp));\n      } else {\n        boom(false);\n      }\n    }\n  }\n\n  return flag;\n}\n\nfunction isAttach() {\n  if (Object.prototype.is !== undefined) {\n    return false;\n  }\n\n  Object.defineProperty(Object.prototype, 'is', {\n    value: function (schema) {\n      return isValid({\n        input: { isProp: this },\n        schema: { isProp: schema }\n      });\n    },\n    writable: true,\n    configurable: true\n  });\n\n  return true;\n}\n\nfunction isFunction$1(fn) {\n  return ['Async', 'Promise', 'Function'].includes(type(fn));\n}\n\nfunction isPromise(x) {\n  return ['Async', 'Promise'].includes(type(x));\n}\n\nfunction isType(xType, x) {\n  if (arguments.length === 1) {\n    return xHolder => isType(xType, xHolder);\n  }\n\n  return type(x) === xType;\n}\n\nasync function mapAsyncFn(fn, arr) {\n  if (Array.isArray(arr)) {\n    const willReturn = [];\n    for (const a of arr) {\n      willReturn.push((await fn(a)));\n    }\n\n    return willReturn;\n  }\n\n  const willReturn = {};\n  for (const prop in arr) {\n    willReturn[prop] = await fn(arr[prop], prop);\n  }\n\n  return willReturn;\n}\n\nfunction mapAsync(fn, arr) {\n  if (arguments.length === 1) {\n    return async holder => mapAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject) => {\n    mapAsyncFn(fn, arr).then(resolve).catch(reject);\n  });\n}\n\nasync function mapFastAsyncFn(fn, arr) {\n  const promised = arr.map(a => fn(a));\n\n  return await Promise.all(promised);\n}\n\nfunction mapFastAsync(fn, arr) {\n  if (arguments.length === 1) {\n    return async holder => mapFastAsyncFn(fn, holder);\n  }\n\n  return new Promise((resolve, reject) => {\n    mapFastAsyncFn(fn, arr).then(resolve).catch(reject);\n  });\n}\n\nfunction mapObject(fn, obj) {\n  const willReturn = {};\n\n  for (const prop in obj) {\n    willReturn[prop] = fn(obj[prop], prop);\n  }\n\n  return willReturn;\n}\n\nfunction map(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => map(fn, arrHolder);\n  }\n\n  if (arr === undefined) {\n    return [];\n  }\n  if (!Array.isArray(arr)) {\n    return mapObject(fn, arr);\n  }\n\n  let index = -1;\n  const len = arr.length;\n  const willReturn = Array(len);\n\n  while (++index < len) {\n    willReturn[index] = fn(arr[index], index);\n  }\n\n  return willReturn;\n}\n\nfunction mergeAll(arr) {\n  let willReturn = {};\n  map(val => {\n    willReturn = merge(willReturn, val);\n  }, arr);\n\n  return willReturn;\n}\n\nfunction check(singleInput, schema) {\n  return isValid({\n    input: { singleInput },\n    schema: { singleInput: schema }\n  });\n}\n\nfunction ok(...inputs) {\n  return (...schemas) => {\n    let failedSchema;\n\n    const pass = any((singleInput, i) => {\n      const schema = schemas[i] === undefined ? schemas[0] : schemas[i];\n\n      const checked = check(singleInput, schema);\n      if (!checked) {\n        failedSchema = JSON.stringify({\n          input: singleInput,\n          schema\n        });\n      }\n\n      return !checked;\n    }, inputs) === false;\n\n    if (!pass) throw new Error(`Failed R.ok with schema ${failedSchema}`);\n\n    return true;\n  };\n}\n\nfunction mapToObject(fn, list) {\n  if (arguments.length === 1) {\n    return listHolder => mapToObject(fn, listHolder);\n  }\n  ok(type(fn), type(list))('Function', 'Array');\n\n  return mergeAll(map(fn, list));\n}\n\nfunction maybe(ifRule, whenIf, whenElse) {\n  return ifRule ? whenIf : whenElse;\n}\n\nfunction sort(fn, arr) {\n  if (arguments.length === 1) return arrHolder => sort(fn, arrHolder);\n\n  const arrClone = arr.concat();\n\n  return arrClone.sort(fn);\n}\n\nconst cache = {};\n\nconst normalizeObject = obj => {\n  const sortFn = (a, b) => a > b;\n  const willReturn = {};\n  compose(map(prop => willReturn[prop] = obj[prop]), sort(sortFn))(Object.keys(obj));\n\n  return willReturn;\n};\n\nconst stringify = a => {\n  if (type(a) === 'String') {\n    return a;\n  } else if (['Function', 'Async'].includes(type(a))) {\n    const compacted = replace(/\\s{1,}/g, ' ', a.toString());\n\n    return replace(/\\s/g, '_', take(15, compacted));\n  } else if (type(a) === 'Object') {\n    a = normalizeObject(a);\n  }\n\n  return JSON.stringify(a);\n};\n\nconst generateProp = (fn, ...inputArguments) => {\n  let propString = '';\n  inputArguments.forEach(inputArgument => {\n    propString += `${stringify(inputArgument)}_`;\n  });\n\n  return `${propString}${stringify(fn)}`;\n};\n\nfunction memoize$1(fn, ...inputArguments) {\n  if (arguments.length === 1) {\n    return (...inputArgumentsHolder) => memoize$1(fn, ...inputArgumentsHolder);\n  }\n  const prop = generateProp(fn, ...inputArguments);\n  if (prop in cache) {\n    return cache[prop];\n  }\n  if (type(fn) === 'Async') {\n    return new Promise(resolve => {\n      fn(...inputArguments).then(result => {\n        cache[prop] = result;\n        resolve(result);\n      });\n    });\n  }\n  const result = fn(...inputArguments);\n  cache[prop] = result;\n\n  return result;\n}\n\nfunction mergeRight(x, y) {\n  return merge(y, x);\n}\n\nfunction pass(...inputs) {\n  return (...schemas) => any((x, i) => {\n    const schema = schemas[i] === undefined ? schemas[0] : schemas[i];\n\n    return !check(x, schema);\n  }, inputs) === false;\n}\n\n//taken from the last comment of https://gist.github.com/mkuklis/5294248\n\nfunction curry(f, a = []) {\n  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);\n}\n\nfunction onceFn(fn, context) {\n  let result;\n\n  return function () {\n    if (fn) {\n      result = fn.apply(context || this, arguments);\n      fn = null;\n    }\n\n    return result;\n  };\n}\n\nfunction once(fn, context) {\n  if (arguments.length === 1) {\n    const wrap = onceFn(fn, context);\n\n    return curry(wrap);\n  }\n\n  return onceFn(fn, context);\n}\n\nfunction otherwise(fallback, toResolve) {\n  if (arguments.length === 1) {\n    return toResolveHolder => otherwise(fallback, toResolveHolder);\n  }\n\n  return new Promise(resolve => {\n    toResolve.then(resolve).catch(e => resolve(fallback(e)));\n  });\n}\n\nfunction path(pathArr, obj) {\n  if (arguments.length === 1) {\n    return objHolder => path(pathArr, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  let willReturn = obj;\n  let counter = 0;\n\n  const pathArrValue = typeof pathArr === 'string' ? pathArr.split('.') : pathArr;\n\n  while (counter < pathArrValue.length) {\n    if (willReturn === null || willReturn === undefined) {\n      return undefined;\n    }\n    willReturn = willReturn[pathArrValue[counter]];\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pathEq(path$$1, target, obj) {\n  if (arguments.length === 2) {\n    return objHolder => pathEq(path$$1, target, objHolder);\n  }\n\n  return path(path$$1, obj) === target;\n}\n\nfunction pipe(...fns) {\n  return compose(...fns.reverse());\n}\n\nfunction piped(...inputs) {\n  const [input, ...fnList] = inputs;\n\n  return pipe(...fnList)(input);\n}\n\nasync function pipedAsync(...inputs) {\n  const [input, ...fnList] = inputs;\n\n  let argumentsToPass = input;\n\n  while (fnList.length !== 0) {\n    const fn = fnList.shift();\n    const typeFn = type(fn);\n\n    if (typeFn === 'Async') {\n      argumentsToPass = await fn(argumentsToPass);\n    } else {\n      argumentsToPass = fn(argumentsToPass);\n    }\n  }\n\n  return argumentsToPass;\n}\n\nfunction helper({ condition, inputArgument, prop }) {\n  return new Promise((resolve, reject) => {\n    if (!(type(condition) === 'Async')) {\n      return resolve({\n        type: prop,\n        payload: condition(inputArgument)\n      });\n    }\n\n    condition(inputArgument).then(result => {\n      resolve({\n        type: prop,\n        payload: result\n      });\n    }).catch(err => reject(err));\n  });\n}\n\nfunction produce(conditions, inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => produce(conditions, inputArgumentHolder);\n  }\n  let asyncConditionsFlag = false;\n  for (const prop in conditions) {\n    if (asyncConditionsFlag === false && type(conditions[prop]) === 'Async') {\n      asyncConditionsFlag = true;\n    }\n  }\n\n  if (asyncConditionsFlag === false) {\n    const willReturn = {};\n    for (const prop in conditions) {\n      willReturn[prop] = conditions[prop](inputArgument);\n    }\n\n    return willReturn;\n  }\n\n  const promised = [];\n  for (const prop in conditions) {\n    const condition = conditions[prop];\n    promised.push(helper({\n      inputArgument,\n      condition,\n      prop\n    }));\n  }\n\n  return new Promise((resolve, reject) => {\n    Promise.all(promised).then(results => {\n      const willReturn = {};\n\n      map(result => willReturn[result.type] = result.payload, results);\n\n      resolve(willReturn);\n    }).catch(err => reject(err));\n  });\n}\n\nfunction promiseAllObject(promises) {\n  return new Promise((res, rej) => {\n    let counter = 0;\n    const props = {};\n    const promisedArr = [];\n\n    for (const prop in promises) {\n      props[counter] = prop;\n      promisedArr.push(promises[prop]);\n      counter++;\n    }\n\n    Promise.all(promisedArr).then(result => {\n      const willReturn = {};\n      result.map((val, key) => {\n        const prop = props[key];\n        willReturn[prop] = val;\n      });\n\n      res(willReturn);\n    }).catch(rej);\n  });\n}\n\nfunction random(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction remove(inputs, text) {\n  if (arguments.length === 1) {\n    return textHolder => remove(inputs, textHolder);\n  }\n\n  if (type(text) !== 'String') {\n    throw new Error(`R.remove requires string not ${type(text)}`);\n  }\n\n  if (type(inputs) !== 'Array') {\n    return replace(inputs, '', text).trim();\n  }\n\n  let textCopy = text;\n\n  inputs.forEach(singleInput => {\n    textCopy = replace(singleInput, '', textCopy).trim();\n  });\n\n  return textCopy;\n}\n\nfunction omit(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => omit(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n\n  for (const key in obj) {\n    if (!keysValue.includes(key)) {\n      willReturn[key] = obj[key];\n    }\n  }\n\n  return willReturn;\n}\n\nfunction renameProps(conditions, inputObject) {\n  if (inputObject === undefined) {\n    return inputObjectHolder => renameProps(conditions, inputObjectHolder);\n  }\n  const renamed = {};\n  Object.keys(conditions).forEach(renameConditionProp => {\n    if (Object.keys(inputObject).includes(renameConditionProp)) {\n      renamed[conditions[renameConditionProp]] = inputObject[renameConditionProp];\n    }\n  });\n\n  return merge(renamed, omit(Object.keys(conditions), inputObject));\n}\n\nconst getOccurances = input => input.match(/{{[_a-zA-Z0-9]+}}/g);\n\nconst getOccuranceProp = occurance => occurance.replace(/{{|}}/g, '');\n\nconst replace$1 = ({ inputHolder, prop, replacer }) => inputHolder.replace(`{{${prop}}}`, replacer);\n\nfunction template(input, templateInput) {\n  if (arguments.length === 1) {\n    return templateInputHolder => template(input, templateInputHolder);\n  }\n  const occurances = getOccurances(input);\n  if (occurances === null) return input;\n\n  let inputHolder = input;\n  for (const occurance of occurances) {\n    const prop = getOccuranceProp(occurance);\n    const replacer = templateInput[prop];\n\n    if (replacer === undefined) continue;\n    inputHolder = replace$1({\n      inputHolder,\n      prop,\n      replacer\n    });\n  }\n\n  return inputHolder;\n}\n\nfunction headObject(x) {\n  if (type(x) !== 'Object') throw new Error('R.headObject.type');\n  const [tag, no] = Object.keys(x);\n  if (tag === undefined) throw new Error('R.headObject.less');\n  if (no !== undefined) throw new Error('R.headObject.more');\n\n  return {\n    prop: tag,\n    value: x[tag]\n  };\n}\n\nconst evaluationsSchema = { label: 'string' };\n\nfunction runTests(input) {\n  const pass = ok(input)({\n    testSuite: 'string',\n    evaluations: [evaluationsSchema]\n  });\n\n  if (describe === undefined || !pass) {\n    throw new Error('R.runTests.init');\n  }\n  try {\n    const { testSuite, evaluations, data } = input;\n\n    describe(testSuite, () => {\n      evaluations.forEach(singleEvaluation => {\n        data.forEach(dataInstance => {\n          const { prop: tag, value: x } = headObject(dataInstance);\n          const { value: evaluationFunction } = headObject(omit('label', singleEvaluation));\n\n          const label = template(singleEvaluation.label, { tag });\n\n          test(label, () => {\n            evaluationFunction(x);\n          });\n        });\n      });\n    });\n  } catch (err) {\n    console.log(err);\n    throw new Error('R.runTestsCatch');\n  }\n}\n\n//https://github.com/staltz/zii\n\nfunction s() {\n  if (Object.prototype.s === undefined) {\n    Object.defineProperty(Object.prototype, 's', {\n      value: function (f) {\n        return f(this.valueOf());\n      },\n      writable: true,\n      configurable: true\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\nconst NO_MATCH_FOUND = Symbol ? /*#__PURE__*/Symbol('NO_MATCH_FOUND') : undefined;\n\nconst getMatchingKeyValuePair = (cases, testValue, defaultValue) => {\n  let iterationValue;\n\n  for (let index = 0; index < cases.length; index++) {\n    iterationValue = cases[index].test(testValue);\n\n    if (iterationValue !== NO_MATCH_FOUND) {\n      return iterationValue;\n    }\n  }\n\n  return defaultValue;\n};\n\nconst isEqual = (testValue, matchValue) => {\n  const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);\n\n  return willReturn;\n};\n\nconst is = (testValue, matchResult = true) => ({\n  key: testValue,\n  test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND\n});\n\nclass Switchem {\n  constructor(defaultValue, cases, willMatch) {\n    if (defaultValue !== undefined && cases === undefined && willMatch === undefined) {\n      this.cases = [];\n      this.defaultValue = undefined;\n      this.willMatch = defaultValue;\n    } else {\n      this.cases = cases;\n      this.defaultValue = defaultValue;\n      this.willMatch = willMatch;\n    }\n\n    return this;\n  }\n\n  default(defaultValue) {\n    const holder = new Switchem(defaultValue, this.cases, this.willMatch);\n\n    return holder.match(this.willMatch);\n  }\n\n  is(testValue, matchResult) {\n    return new Switchem(this.defaultValue, [...this.cases, is(testValue, matchResult)], this.willMatch);\n  }\n\n  match(matchValue) {\n    return getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);\n  }\n}\n\nfunction switcher(input) {\n  return new Switchem(input);\n}\n\nfunction tapAsync(fn, input) {\n  if (arguments.length === 1) {\n    return inputHolder => tapAsync(fn, inputHolder);\n  }\n  if (isPromise(fn) === true) {\n    return new Promise((resolve, reject) => {\n      fn(input).then(() => {\n        resolve(input);\n      }).catch(reject);\n    });\n  }\n  fn(input);\n\n  return input;\n}\n\nfunction then(afterResolve, toResolve) {\n  if (arguments.length === 1) {\n    return toResolveHolder => then(afterResolve, toResolveHolder);\n  }\n\n  return new Promise(resolve => {\n    toResolve.then(result => resolve(afterResolve(result)));\n  });\n}\n\nfunction throttle(fn, ms) {\n  let wait = false;\n\n  return function (...input) {\n    if (!wait) {\n      fn.apply(null, input);\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n      }, ms);\n    }\n  };\n}\n\nfunction tryCatch(fn, fallback) {\n  if (!isFunction$1(fn)) {\n    throw new Error(`R.tryCatch | fn '${fn}'`);\n  }\n  const passFallback = isFunction$1(fallback);\n\n  if (!isPromise(fn)) {\n    return (...inputs) => {\n      try {\n        return fn(...inputs);\n      } catch (e) {\n        return passFallback ? fallback(...inputs) : fallback;\n      }\n    };\n  }\n\n  return (...inputs) => new Promise(resolve => {\n    fn(...inputs).then(resolve).catch(() => {\n      if (!passFallback) {\n        return resolve(fallback);\n      }\n\n      if (!isPromise(fallback)) {\n        return resolve(fallback(...inputs));\n      }\n\n      fallback(...inputs).then(resolve);\n    });\n  });\n}\n\nfunction wait(fn) {\n  return new Promise(resolve => {\n    fn.then(result => resolve([result])).catch(e => resolve([, e]));\n  });\n}\n\nfunction range(start, end) {\n  if (arguments.length === 1) return endHolder => range(start, endHolder);\n\n  const willReturn = [];\n\n  for (let i = start; i < end; i++) {\n    willReturn.push(i);\n  }\n\n  return willReturn;\n}\n\nfunction waitFor(condition, howLong, loops = 10) {\n  const typeCondition = type(condition);\n\n  const passPromise = typeCondition === 'Async';\n  const passFunction = typeCondition === 'Function';\n  const interval = Math.floor(howLong / loops);\n\n  if (!(passPromise || passFunction)) {\n    throw new Error('R.waitFor');\n  }\n\n  if (passFunction) {\n    return async (...inputs) => {\n      for (const i of range(0, loops)) {\n        const resultCondition = condition(...inputs);\n\n        if (resultCondition === false) {\n          await delay(interval);\n        } else {\n          return resultCondition;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  return async (...inputs) => {\n    for (const i of range(0, loops)) {\n      const resultCondition = await condition(...inputs);\n\n      if (resultCondition === false) {\n        await delay(interval);\n      } else {\n        return resultCondition;\n      }\n    }\n\n    return false;\n  };\n}\n\nfunction when(condition, whenTrue) {\n  if (arguments.length === 1) {\n    return whenTrueHolder => when(condition, whenTrueHolder);\n  }\n\n  return input => {\n    const flag = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (!flag) return input;\n\n    if (isFunction$1(whenTrue)) return whenTrue(input);\n\n    return whenTrue;\n  };\n}\n\nfunction createThenable$1(x) {\n  return async function (input) {\n    return x(input);\n  };\n}\n\nfunction whenAsync(condition, whenTrueFn) {\n  if (arguments.length === 1) {\n    return whenTrueFnHolder => whenAsync(condition, whenTrueFnHolder);\n  }\n\n  return input => new Promise((resolve, reject) => {\n    const whenTrueFnPromise = createThenable$1(whenTrueFn);\n\n    if (typeof condition === 'boolean') {\n      if (condition === false) {\n        return resolve(input);\n      }\n\n      whenTrueFnPromise(input).then(resolve).catch(reject);\n    } else {\n      const conditionPromise = createThenable$1(condition);\n\n      conditionPromise(input).then(conditionResult => {\n        if (conditionResult === false) {\n          return resolve(input);\n        }\n\n        whenTrueFnPromise(input).then(resolve).catch(reject);\n      }).catch(reject);\n    }\n  });\n}\n\nfunction where(conditions, obj) {\n  if (obj === undefined) {\n    return objHolder => where(conditions, objHolder);\n  }\n  let flag = true;\n  for (const prop in conditions) {\n    const result = conditions[prop](obj[prop]);\n    if (flag && result === false) {\n      flag = false;\n    }\n  }\n\n  return flag;\n}\n\nfunction whereEq(rule, input) {\n  if (arguments.length === 1) {\n    return inputHolder => whereEq(rule, inputHolder);\n  }\n  if (type(input) !== 'Object') return false;\n\n  const result = filter((ruleValue, ruleProp) => equals(ruleValue, input[ruleProp]), rule);\n\n  return Object.keys(result).length === Object.keys(rule).length;\n}\n\nfunction add(x, y) {\n  if (y === undefined) {\n    return yHolder => add(x, yHolder);\n  }\n\n  return x + y;\n}\n\nfunction adjustRaw(fn, index, arr) {\n  const clone = arr.concat();\n\n  return clone.map((val, key) => {\n    if (key === index) {\n      return fn(arr[index]);\n    }\n\n    return val;\n  });\n}\n\nconst adjust = /*#__PURE__*/curry(adjustRaw);\n\nfunction allPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => allPass(conditions, xHolder);\n  }\n\n  return !any(condition => !condition(x), conditions);\n}\n\nfunction always(x) {\n  return () => x;\n}\n\nfunction anyPass(conditions, x) {\n  if (arguments.length === 1) {\n    return xHolder => anyPass(conditions, xHolder);\n  }\n\n  return any(condition => condition(x))(conditions);\n}\n\nfunction append(x, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => append(x, arrHolder);\n  }\n\n  if (typeof arr === 'string') return `${arr}${x}`;\n\n  const clone = arr.concat();\n  clone.push(x);\n\n  return clone;\n}\n\nfunction assocRaw(prop, value, obj) {\n  return Object.assign({}, obj, { [prop]: value });\n}\n\nconst assoc = /*#__PURE__*/curry(assocRaw);\n\nfunction both(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => both(x, yHolder);\n  }\n\n  return input => x(input) && y(input);\n}\n\nfunction complement(fn) {\n  return input => !fn(input);\n}\n\nfunction concat(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => concat(x, yHolder);\n  }\n\n  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];\n}\n\nconst dec = x => x - 1;\n\nfunction flagIs$1(inputArgument) {\n  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true;\n}\n\nfunction defaultTo(defaultArgument, ...inputArgument) {\n  if (arguments.length === 1) {\n    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);\n  }\n  if (arguments.length === 2) {\n    return flagIs$1(inputArgument[0]) ? defaultArgument : inputArgument[0];\n  }\n\n  const limit = inputArgument.length - 1;\n  let len = limit + 1;\n  let ready = false;\n  let holder;\n\n  while (!ready) {\n    const instance = inputArgument[limit - len + 1];\n\n    if (len === 0) {\n      ready = true;\n    } else if (flagIs$1(instance)) {\n      len = len - 1;\n    } else {\n      holder = instance;\n      ready = true;\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder;\n}\n\nfunction dissoc(prop, obj) {\n  if (arguments.length === 1) {\n    return objHolder => dissoc(prop, objHolder);\n  }\n\n  if (obj === null || obj === undefined) {\n    return {};\n  }\n\n  const willReturn = {};\n  for (const p in obj) {\n    willReturn[p] = obj[p];\n  }\n  delete willReturn[prop];\n\n  return willReturn;\n}\n\nfunction divide(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => divide(x, yHolder);\n  }\n\n  return x / y;\n}\n\nfunction drop(dropNumber, x) {\n  if (arguments.length === 1) {\n    return xHolder => drop(dropNumber, xHolder);\n  }\n\n  return x.slice(dropNumber);\n}\n\nfunction dropLast(dropNumber, x) {\n  if (arguments.length === 1) {\n    return xHolder => dropLast(dropNumber, xHolder);\n  }\n\n  return x.slice(0, -dropNumber);\n}\n\nfunction either(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => either(x, yHolder);\n  }\n\n  return input => x(input) || y(input);\n}\n\nfunction endsWith(substr, str) {\n  if (arguments.length === 1) {\n    return strHolder => endsWith(substr, strHolder);\n  }\n\n  return str.endsWith(substr);\n}\n\nfunction F() {\n  return false;\n}\n\nfunction find(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => find(fn, arrHolder);\n  }\n\n  return arr.find(fn);\n}\n\nfunction findIndex(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => findIndex(fn, arrHolder);\n  }\n\n  const len = arr.length;\n  let index = -1;\n\n  while (++index < len) {\n    if (fn(arr[index], index)) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction flatten(arr, willReturn) {\n  willReturn = willReturn === undefined ? [] : willReturn;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      flatten(arr[i], willReturn);\n    } else {\n      willReturn.push(arr[i]);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction flipExport(fn) {\n  return (...input) => {\n    if (input.length === 1) {\n      return holder => fn(holder, input[0]);\n    } else if (input.length === 2) {\n      return fn(input[1], input[0]);\n    }\n\n    return undefined;\n  };\n}\n\nfunction flip(fn) {\n  return flipExport(fn);\n}\n\nfunction forEach(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => forEach(fn, arrHolder);\n  }\n\n  map(fn, arr);\n\n  return arr;\n}\n\nfunction groupBy(fn, list) {\n  if (arguments.length === 1) {\n    return listHolder => groupBy(fn, listHolder);\n  }\n\n  const result = {};\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    const key = fn(item);\n\n    if (!result[key]) {\n      result[key] = [];\n    }\n\n    result[key].push(item);\n  }\n\n  return result;\n}\n\nfunction has(prop, obj) {\n  if (arguments.length === 1) {\n    return objHolder => has(prop, objHolder);\n  }\n\n  return obj[prop] !== undefined;\n}\n\nfunction head(a) {\n  if (typeof a === 'string') {\n    return a[0] || '';\n  }\n\n  return a[0];\n}\n\nfunction identity(x) {\n  return x;\n}\n\nfunction ifElse(condition, ifFn, elseFn) {\n  if (ifFn === undefined) {\n    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);\n  } else if (elseFn === undefined) {\n    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);\n  }\n\n  return input => {\n    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);\n\n    if (conditionResult === true) {\n      return ifFn(input);\n    }\n\n    return elseFn(input);\n  };\n}\n\nconst inc = x => x + 1;\n\nfunction includes(target, input) {\n  if (arguments.length === 1) {\n    return inputHolder => includes(target, inputHolder);\n  }\n  const ok = Array.isArray(input) || typeof input === 'string';\n  if (!ok) return false;\n\n  return input.includes(target);\n}\n\nfunction indexBy(fn, list) {\n  if (arguments.length === 1) {\n    return listHolder => indexBy(fn, listHolder);\n  }\n\n  const result = {};\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    result[fn(item)] = item;\n  }\n\n  return result;\n}\n\nfunction indexOf(x, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => indexOf(x, arrHolder);\n  }\n\n  let index = -1;\n  const length = arr.length;\n\n  while (++index < length) {\n    if (arr[index] === x) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction is$1(xPrototype, x) {\n  if (arguments.length === 1) {\n    return xHolder => is$1(xPrototype, xHolder);\n  }\n\n  return x != null && x.constructor === xPrototype || x instanceof xPrototype;\n}\n\nfunction isNil(x) {\n  return x === undefined || x === null;\n}\n\nfunction join(glue, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => join(glue, arrHolder);\n  }\n\n  return arr.join(glue);\n}\n\nfunction keys(x) {\n  return Object.keys(x);\n}\n\nfunction lastIndexOf(x, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => lastIndexOf(x, arrHolder);\n  }\n\n  let willReturn = -1;\n\n  arr.map((value, key) => {\n    if (equals(value, x)) {\n      willReturn = key;\n    }\n  });\n\n  return willReturn;\n}\n\nfunction length(x) {\n  return x.length;\n}\n\nfunction match(regex, x) {\n  if (arguments.length === 1) {\n    return xHolder => match(regex, xHolder);\n  }\n\n  const willReturn = x.match(regex);\n\n  return willReturn === null ? [] : willReturn;\n}\n\nfunction max(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => max(x, yHolder);\n  }\n\n  return y > x ? y : x;\n}\n\nfunction maxBy(fn, x, y) {\n  if (arguments.length === 2) {\n    return yHolder => maxBy(fn, x, yHolder);\n  } else if (arguments.length === 1) {\n    return (xHolder, yHolder) => maxBy(fn, xHolder, yHolder);\n  }\n\n  return fn(y) > fn(x) ? y : x;\n}\n\nfunction min(x, y) {\n  if (arguments.length === 1) {\n    return yHolder => min(x, yHolder);\n  }\n\n  return y < x ? y : x;\n}\n\nfunction minBy(fn, x, y) {\n  if (arguments.length === 2) {\n    return yHolder => minBy(fn, x, yHolder);\n  } else if (arguments.length === 1) {\n    return (xHolder, yHolder) => minBy(fn, xHolder, yHolder);\n  }\n\n  return fn(y) < fn(x) ? y : x;\n}\n\nfunction modulo(x, y) {\n  if (arguments.length === 1) return yHolder => modulo(x, yHolder);\n\n  return x % y;\n}\n\nfunction multiply(x, y) {\n  if (arguments.length === 1) return yHolder => multiply(x, yHolder);\n\n  return x * y;\n}\n\nfunction none(fn, arr) {\n  if (arguments.length === 1) return arrHolder => none(fn, arrHolder);\n\n  return arr.filter(fn).length === 0;\n}\n\nfunction not(x) {\n  return !x;\n}\n\nfunction nth(index, list) {\n  if (arguments.length === 1) return listHolder => nth(index, listHolder);\n\n  const idx = index < 0 ? list.length + index : index;\n\n  return Object.prototype.toString.call(list) === '[object String]' ? list.charAt(idx) : list[idx];\n}\n\nfunction partialCurry(fn, inputArguments = {}) {\n  return inputArgumentsHolder => {\n    if (type(fn) === 'Async' || type(fn) === 'Promise') {\n      return new Promise((resolve, reject) => {\n        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);\n      });\n    }\n\n    return fn(merge(inputArgumentsHolder, inputArguments));\n  };\n}\n\nfunction pathOrRaw(defaultValue, inputPath, inputObject) {\n  return defaultTo(defaultValue, path(inputPath, inputObject));\n}\n\nconst pathOr = /*#__PURE__*/curry(pathOrRaw);\n\nfunction pickAll(keys, obj) {\n  if (arguments.length === 1) {\n    return objHolder => pickAll(keys, objHolder);\n  }\n  if (obj === null || obj === undefined) {\n    return undefined;\n  }\n  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;\n\n  const willReturn = {};\n  let counter = 0;\n\n  while (counter < keysValue.length) {\n    if (keysValue[counter] in obj) {\n      willReturn[keysValue[counter]] = obj[keysValue[counter]];\n    } else {\n      willReturn[keysValue[counter]] = undefined;\n    }\n    counter++;\n  }\n\n  return willReturn;\n}\n\nfunction pluck(keyToPluck, arr) {\n  if (arguments.length === 1) return arrHolder => pluck(keyToPluck, arrHolder);\n\n  const willReturn = [];\n\n  map(val => {\n    if (!(val[keyToPluck] === undefined)) {\n      willReturn.push(val[keyToPluck]);\n    }\n  }, arr);\n\n  return willReturn;\n}\n\nfunction prepend(x, arr) {\n  if (arguments.length === 1) return arrHolder => prepend(x, arrHolder);\n\n  if (typeof arr === 'string') {\n    return `${x}${arr}`;\n  }\n  const clone = arr.concat();\n  clone.unshift(x);\n\n  return clone;\n}\n\nfunction prop(key, obj) {\n  if (arguments.length === 1) return objHolder => prop(key, objHolder);\n\n  return obj[key];\n}\n\nfunction propEq(key, x, obj) {\n  if (x === undefined) {\n    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);\n  } else if (obj === undefined) {\n    return objHolder => propEq(key, x, objHolder);\n  }\n\n  return obj[key] === x;\n}\n\nfunction reduce(fn, initialValue, arr) {\n  if (initialValue === undefined) {\n    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => reduce(fn, initialValue, arrHolder);\n  }\n\n  return arr.reduce(fn, initialValue);\n}\n\nfunction reject(fn, arr) {\n  if (arguments.length === 1) return arrHolder => reject(fn, arrHolder);\n\n  return filter((x, i) => !fn(x, i), arr);\n}\n\nfunction repeat(x, num) {\n  if (arguments.length === 1) {\n    return numHolder => repeat(x, numHolder);\n  }\n  const willReturn = Array(num);\n\n  return willReturn.fill(x);\n}\n\nfunction reverse(arr) {\n  const clone = arr.concat();\n\n  return clone.reverse();\n}\n\nfunction sortBy(fn, arr) {\n  if (arguments.length === 1) {\n    return arrHolder => sortBy(fn, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.sort((a, b) => {\n    const fnA = fn(a);\n    const fnB = fn(b);\n\n    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;\n  });\n}\n\nfunction split(glue, str) {\n  if (arguments.length === 1) return strHolder => split(glue, strHolder);\n\n  return str.split(glue);\n}\n\nfunction splitEvery(num, x) {\n  if (arguments.length === 1) return xHolder => splitEvery(num, xHolder);\n\n  const numValue = num > 1 ? num : 1;\n\n  const willReturn = [];\n  let counter = 0;\n\n  while (counter < x.length) {\n    willReturn.push(x.slice(counter, counter += numValue));\n  }\n\n  return willReturn;\n}\n\nfunction startsWith(x, y) {\n  if (arguments.length === 1) return yHolder => startsWith(x, yHolder);\n\n  return y.startsWith(x);\n}\n\nfunction subtract(x, y) {\n  if (arguments.length === 1) return yHolder => subtract(x, yHolder);\n\n  return x - y;\n}\n\nfunction T() {\n  return true;\n}\n\nfunction tail(arr) {\n  return drop(1, arr);\n}\n\nfunction takeLast(num, x) {\n  if (arguments.length === 1) return xHolder => takeLast(num, xHolder);\n\n  const len = x.length;\n\n  let numValue = num > len ? len : num;\n\n  if (typeof x === 'string') {\n    return x.slice(len - numValue);\n  }\n  numValue = len - numValue;\n\n  return baseSlice(x, numValue, len);\n}\n\nfunction tap(fn, x) {\n  if (arguments.length === 1) return xHolder => tap(fn, xHolder);\n\n  fn(x);\n\n  return x;\n}\n\nfunction times(fn, num) {\n  if (arguments.length === 1) return numHolder => times(fn, numHolder);\n\n  return map(fn, range(0, num));\n}\n\nfunction toString$1(x) {\n  return x.toString();\n}\n\nfunction toUpper(x) {\n  return x.toUpperCase();\n}\n\nfunction trim(str) {\n  return str.trim();\n}\n\nfunction uniq(arr) {\n  let index = -1;\n  const willReturn = [];\n\n  while (++index < arr.length) {\n    const value = arr[index];\n\n    if (!contains(value, willReturn)) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction uniqWith(fn, arr) {\n  if (arguments.length === 1) return arrHolder => uniqWith(fn, arrHolder);\n\n  let index = -1;\n  const len = arr.length;\n  const willReturn = [];\n\n  while (++index < len) {\n    const value = arr[index];\n    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);\n\n    if (!flag) {\n      willReturn.push(value);\n    }\n  }\n\n  return willReturn;\n}\n\nfunction update(index, newValue, arr) {\n  if (newValue === undefined) {\n    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);\n  } else if (arr === undefined) {\n    return arrHolder => update(index, newValue, arrHolder);\n  }\n  const arrClone = arr.concat();\n\n  return arrClone.fill(newValue, index, index + 1);\n}\n\nfunction values(obj) {\n  const willReturn = [];\n\n  for (const key in obj) {\n    willReturn.push(obj[key]);\n  }\n\n  return willReturn;\n}\n\nfunction without(itemsToOmit, collection) {\n  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);\n}\n\n/**\n * Taken from \n * https://github.com/Nozbe/WatermelonDB/blob/master/src/utils/fp/zip/index.js\n */\n\nfunction zip(left, right) {\n  if (right === undefined) {\n    return function (right) {\n      return zip(left, right);\n    };\n  }\n\n  var result = [];\n  var length = Math.min(left.length, right.length);\n\n  for (var i = 0; i < length; i++) {\n    result[i] = [left[i], right[i]];\n  }\n\n  return result;\n}\n\nfunction zipObj(x, y) {\n  if (arguments.length === 1) return yHolder => zipObj(x, yHolder);\n\n  return x.reduce((prev, xInstance, i) => {\n    prev[xInstance] = y[i];\n\n    return prev;\n  }, {});\n}\n\nconst DELAY = 'RAMBDAX_DELAY';\n\nexport { DELAY, ok, complement as opposite, allFalse, allTrue, allType, anyFalse, anyTrue, anyType, change, composeAsync, composed, count, debounce, defaultToStrict, defaultToWhen, delay, findInObject, findModify, flatMap, getter, setter, reset, glue, ifElseAsync, includesAny, includesType, inject, interval, isAttach, isFunction$1 as isFunction, isPromise, isType, isValid, mapAsync, mapFastAsync, mapToObject, maybe, memoize$1 as memoize, mergeAll, mergeRight, pass, once, otherwise, pathEq, piped, pipedAsync, produce, partition, promiseAllObject, random, remove, renameProps, runTests, s, shuffle, switcher, tapAsync, template, then, throttle, tryCatch, wait, waitFor, when, whenAsync, where, whereEq, add, adjust, all, allPass, always, any, anyPass, append, assoc, both, complement, compose, concat, contains, curry, dec, defaultTo, dissoc, divide, drop, dropLast, either, endsWith, equals, F, filter, find, findIndex, flatten, flip, forEach, groupBy, has, head, identity, ifElse, inc, includes, indexBy, indexOf, init, is$1 as is, isNil, join, keys, last, lastIndexOf, length, map, match, merge, max, maxBy, min, minBy, modulo, multiply, none, not, nth, omit, partialCurry, path, pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, range, reduce, reject, repeat, replace, reverse, sort, sortBy, split, splitEvery, startsWith, subtract, T, tail, take, takeLast, tap, test$1 as test, times, toLower, toString$1 as toString, toUpper, trim, type, uniq, uniqWith, update, values, without, zip, zipObj };\n//# sourceMappingURL=rambdax.esm.js.map\n","import { sort } from 'rambdax'\n\nexport const getMaxLength = lines => {\n  const [ max ] = sort((a, b) => a.length < b.length ? 1 : -1)(lines)\n\n  return max.length\n}\n","import { dropLast, trim } from 'rambdax'\nimport { splitPerLine } from './splitPerLine'\n\nconst BUFFER = 3\n\nexport function fitWithinLines({\n  limit,\n  perLine = 30,\n  text,\n}){\n  let counter = perLine\n  const len = text.length\n  let answer\n\n  while (counter < len){\n    counter++\n    const maybeAnswer = splitPerLine({\n      text,\n      perLine : counter,\n    })\n    if (maybeAnswer.length <= limit){\n      answer = maybeAnswer\n      counter = len\n    } else if (counter + BUFFER === len){\n\n    }\n  }\n\n  if (!answer){\n    const partial = trim(dropLast(BUFFER, text))\n    if (partial.length < BUFFER * 2){\n      throw new Error(`such text cannot fit within ${ limit } lines`)\n    }\n\n    return fitWithinLines({\n      text : partial,\n      perLine,\n      limit,\n    })\n  }\n\n  return answer\n}\n","import { HTML_TAGS } from './internals/constants'\nimport { replace } from 'rambda'\n\nexport function stripTags(str){\n  return replace(\n    /\\s+/g,\n    ' ',\n    replace(\n      HTML_TAGS,\n      ' ',\n      str\n    )\n  ).trim()\n}\n","import { map, merge, defaultTo } from 'rambda'\nimport { camelCase } from './camelCase'\n\nfunction mergeAll(arr){\n  let willReturn = {}\n  map(val => {\n    willReturn = merge(willReturn, val)\n  }, arr)\n\n  return willReturn\n}\n\nfunction mapToObject(fn, list){\n  return mergeAll(map(fn, list))\n}\n\nexport function takeArguments(url, sep = '?', rawFlag = false){\n  const [ , ...rawArguments ] = url.split(sep)\n  if (rawArguments.length === 0) return {}\n\n  return mapToObject(x => {\n    const [ keyRaw, value ] = x.split('=')\n    const key = rawFlag ? keyRaw : camelCase(keyRaw)\n    if (value === undefined || value === 'true'){\n      return { [ key ] : true }\n    }\n    if (value === 'false'){\n      return { [ key ] : false }\n    }\n\n    if (Number.isNaN(Number(value))){\n      return { [ key ] : value }\n    }\n\n    return { [ key ] : Number(value) }\n  }, rawArguments)\n}\n","import {\n  join,\n  map,\n  head,\n  toUpper,\n  toLower,\n  tail,\n} from 'rambda'\nimport { words } from './words'\nimport { wordsX } from './wordsX'\n\nexport function titleCase(str, extraLatin = false){\n  const method = extraLatin ?\n    wordsX :\n    words\n    \n  return join(\n    ' ',\n    map(\n      val => `${ toUpper(head(val)) }${ toLower(tail(val)) }`,\n      method(str)\n    )\n  )\n}\n"],"names":["between","str","left","rightRaw","right","undefined","rightIndex","lastIndexOf","leftIndex","indexOf","substring","length","trim","test","WORDS","WORDS_EXTENDED","PUNCTUATIONSX","PUNCTUATIONS","HTML_TAGS","words","match","wordsX","camelCase","extraLatin","method","result","join","map","val","toUpper","head","toLower","tail","count","substr","split","constantCase","compose","distance","a","b","i","j","prev","tmp","row","Array","Math","min","normalizeGermanChar","char","arr","normalizedArr","foundIndex","normalizeGermanWord","distanceGerman","dotCase","glob","globStr","numGlobs","endsWith","last","startsWith","init","indent","indentCount","repeat","isLetter","isPunctuation","kebabCase","replace","humanLengths","globs","len","chance","random","getGlob","mode","easyFive","base","maybeKey","ant","word","replacer","chars","maskWordHelper","charLimit","maskWordHelperX","easyMode","easierMode","randomMode","addSpaceAroundPunctuation","sentence","x","maskSentence","parsed","hidden","visible","input","easyFn","partialCurry","ok","includes","visiblePart","push","maskWords","parseInput","inputRaw","Error","numbers","flag","forEach","isNumber","Number","hash","findInHash","hashKey","found","Object","keys","filter","singleKey","ms","miliseconds","floor","pascalCase","removeIndent","trimLeft","reverse","seoTitle","limit","shuffleArr","counter","index","temp","shuffle","snakeCase","workingMan","partialSplitted","perLine","lengthHolder","didOverflow","willReturn","overTheTop","currentInstance","mystery","okCounter","isOver","newPartialSplitted","slice","splitPerLine","splitted","text","splitChar","readyForPush","end","singleAnswer","splitSentence","stripPunctuation","toString","sort","dropLast","getMaxLength","lines","max","BUFFER","fitWithinLines","answer","maybeAnswer","partial","stripTags","mergeAll","merge","mapToObject","fn","list","takeArguments","url","sep","rawFlag","rawArguments","keyRaw","value","key","isNaN","titleCase"],"mappings":"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"}